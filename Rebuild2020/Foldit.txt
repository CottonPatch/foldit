Glossary:

  DRW = Deep Rebuild ?Worst?
  bridgesaving
  CI = Clash Importance
  ED = Electron Density puzzle
  qStab
  Fuse (Fuzing)
  Layer Filter
  nr = number
  RB = Recent Best
  WF = Wiggle Factor


Built-in Global Variables:
  Hello World 2
  Yet another change
 
Built-in functions:

  print("Active subscore: "..Subs[i])
  type(types)
  xpcall(DRW,Cleanup)

  band.GetCount()
  behavior.GetClashImportance()
  behavior.SetClashImportance(CInr * CIfactor)
  behavior.SetSlowFiltersDisabled(true)
  current.GetExplorationMultiplier()
  current.GetSegmentEnergyScore(i)
  current.GetSegmentEnergySubscore(i,'density')
  current.GetSegmentEnergySubscore(i,'disulfides')
  current.GetSegmentEnergySubscore(i,'reference')
  current.GetSegmentEnergySubscore(j,Subs[i])
  dialog.CreateDialog("Clash importance is not 1")
  dialog.AddButton("Continue",1)
  dialog.AddCheckbox("Run with disabled slow filters",Filteractive)
  dialog.AddLabel("Last change to change it")
  dialog.AddSlider("MinGain:",minGain,0,500,0)
  dialog.AddTextbox("Set maxbonus:",maxbonus)
  dialog.Show(ask)
  freeze.IsFrozen(i)
  *known* math.abs(current.GetSegmentEnergySubscore(j,Subs[i]))
  pose.GetEnergyScore()
  pose.GetExplorationMultiplier()
  pose.GetSegmentEnergyScore(i)
  pose.GetSegmentEnergySubscore(i,types)
  puzzle.GetPuzzleSubscoreNames()
  recentbest.Restore()
  recentbest.Save()
  save.Quickload(98)
  save.Quicksave(99)
  save.LoadSecondaryStructure()
  save.SaveSecondaryStructure()
  selection.DeselectAll()
  selection.IsSelected(i)
  selection.Select(i)
  selection.SelectAll()
  selection.SelectRange(set[i][1],set[i][2])
  structure.GetAminoAcid(i)
  structure.GetCount()
  structure.GetDistance(x,i)
  structure.GetSecondaryStructure(segCnt2)
  structure.SetSecondaryStructureSelected(aa)
  structure.IsMutable(i)
  structure.IsLocked(i)
  structure.MutateSidechainsSelected(maxitter)
  structure.RebuildSelected(i)
  structure.ShakeSidechainsAll(1)
  structure.ShakeSidechainsSelected(1)
  structure.WiggleAll(2*wf*iters,true,false)
  structure.WiggleSelected(2*wf*iters,true,false)
  *known* table.insert(nums, tonumber(v))
  *known* table.sort(list)
  user.GetPlayerName()
  
User-defined Global Variables:

  action="rebuild"
  ActiveSub=FindActiveSubscores(true)
  AfterFuze=false
  AfterQstab=false
  AfterRB=false
  areas={ --start segment, end segment. use for last line call}
  bandflip= band.GetCount() > 0
  BeFuze=false
  bestScore=Score()
  BetterRecentBest=false
  Blocked={} --A simple list so we can clear Donepart
  *CInr = Clash Importance number/percent ( 0.00 to 0.99 )
  CIfactor=1
  clrdonelistgain=segCnt
  CURBONUS=maxbonus
  curclrscore=Score()
  Cyslist={} -- number of cystine amino acids
  DENSITYWEIGHT=0
  Disj={} --To administrate which segments have be touched
  disjunt ??typo??
  disjunct=false
  Donepart={} --To find fast if to be skipped
  donotrevisit=true
  doShake=true --false --shake rebuilded area (only!) every rebuild, slowing down process
  doSpecial=false -- local shake, wiggle sidec, wiggle backbone, even slower
  DRWstartscore=0
  DRWVersion="3.0.2"
  fastQstab=true --false --if true faster stabilize, but longer
  Filteractive=ask.disable.value
  FilterOffscore=Score()
  Filterscore=Score()
  firstDRWcall=true
  firstRBseg=0
  FREEDESIGN=false
  HASDENSITY=false
  HASLIGAND= (segCnt2<segCnt)
  HASMUTABLE=false
  helices=true --false --rebuild helices + surrounding loops
  InQstab=false
  ISAUNTDEEN=false
  lastRBseg=0
  lastSegScores=0
  len=6 --find worst segments part
  localshakes=true
  loops=true --rebuild loops alone
  maxbonus=Filterscore-FilterOffscore
  maxCI=true
  maxLen=4 -- and maximim len
  maxlossbeforefuze=(segCnt2-segCnt2%4)/4 -- if loss is more no fuze is done
  maxnrofRuns=40 -- Set it very high if you want to run forever
  minGain=(segCnt2-segCnt2%4)/4 -- If less gain then try the next one, else recompute
  minLen=2 --or specify minimum len
  MutateCI=0.9
  MUTRB=false
  MutSphere=8
  MutSur
  MUTSur=false
  nextslot=6
  normal = TRUE or FALSE (current.GetExplorationMultiplier() == 0)
  nrofbridges=0
  nrskip=0
  PROBABLESYM=false -- Probable symmetry type puzzle or has bonuses
  progname="DRW "
  reBuild=4 --up to worst parts to look at
  rebuildCI=0 --clash importance while rebuild
  reBuildmore=1 --increased by every main cycle
  rebuilds=15 --how many rebuilds to try, set at least 10!
  Runnr=0
  SAFESelection
  savebridges=false -- default no bridgechecking
  SAVEDstructs=false
  ScoreParts={ --{save_no,name,active,longname}
  Scores={} --{save_no,points,totscore,showlist,todo,rbnr}
  scrPart={}
  segCnt = structure.GetCount()
  segCnt2 = segCnt
  SegmentScores={} --Optimalisation for fast worst search
  shakeCI=0.31 --clash imortance while shaking
  sheets=false --rebuild sheets + surrounding loops
  skipfuze=false
  skipqstab=false
  Slot4=false
  SlotAll=true
  slotScr
  StackMarks={}
  Stackmin=60
  StackPos=60
  struct=false --set in all loop (if true work in structure mode)
  WF=1 -- Wiggle Factor
  WORKON={{1,segCnt2}}
  WORKONbool={}


User-defined functions:

  function AddDone(first,last)
  function AddLoop(sS)
  function AddOther(sS)
  function AllLoop() --turning entire structure to loops
  function askAUNT()
  function AskDRWOptions()
  function AskForSelections(title,mode)
  function AskMoreOptions()
  function AskMutateOptions()
  function AskSelScores()
  function AskSubScores()
  function Bridgerestore()
  function Bridgesave()
  function BridgesBroken()
  function CheckCI() -- Clash Importance 
  function CheckDone(first,last)
  function Checknums(nums)
  function ChkDisjunctList(n)
  function ChkDoneList()
  function CI(CInr) -- Clash Importance 
  function Cleanup(err)
  function ClearDoneList()
  function ClearScores()
  function ClrTopPosition()
  function CountBridges()
  function DeepRebuild()
  function doMutate()
  function DRcall(how) -- Deep Rebuild
  function DRW()
  function Filter()
  function FilterOff()
  function FilterOn()
  function FindAAtype(aa)
  function FindAAtypeList(aa)
  function FindActiveSubscores(show)
  function FindAminotype(at) --NOTE: only this one gives a list not a set
  function FindAreas()
  function FindFrozen()
  function FindFrozenList()
  function FindLocked()
  function FindLockedList()
  function FindMutables()
  function FindMutablesList()
  function FindSelected()
  function FindSelectedList()
  function FindWorst(firsttime)
  function Fuze(slot,prefun,postfun,globshake)
  function Fuze1(ci1,ci2,prefun,postfun,globshake)
  function Fuze2(ci1,ci2,prefun,postfun)
  function FuzeEnd(prefun,postfun)
  function getPartscore(ss,se,attr)
  function GetRB(prefun,postfun) -- Get recent best
  function GetSegmentScores()
  function GetSubscore(types,seg1,seg2,pose)
  function GetTopPosition()
  function InitWORKONbool()
  function IsBridge(i)
  function ListSlots()
  function localRebuild(maxiters)
  function MustWorkon(i,j)
  function MutateAll(maxitter)
  function MutateSel(maxitter)
  function PopPosition()
  function PopMarkPosition()
  function PrintAreas()
  function printOptions(title)
  function PushMarkPosition()
  function PushPosition()
  function qStab()
  function RBScore() -- RB = Recent Best
  function ReadSegmentSet(data)
  function ReBuild(ss,se,tries)
  function reFuze(scr,slot)
  function round3(x) -- cut all after 3-rd place
  function SaveBest()
  function SaveScores(ss,se,RBnr)
  function Score(pose) -- pose can be nil; if pose==nil then pose=current
  function SegmentCleanSet(set)
  function SegmentCommList(list1,list2)
  function SegmentCommSet(set1,set2)
  function SegmentInList(s,list)
  function SegmentInSet(set,s)
  function SegmentInvertList(list)
  function SegmentInvertSet(set,maxseg)
  function SegmentJoinList(list1,list2)
  function SegmentJoinSet(set1,set2)
  function SegmentListToSet(list)
  function SegmentPrintSet(set)
  function SegmentRangeInSet(set,range)
  function SegmentSetInSet(set,sub)
  function SegmentSetMinus(set1,set2)
  function SegmentSetToBool(set)
  function SegmentSetToList(set)
  function SegmentSetToString(set)
  function SegScore(pose)
  function SelectAround(ss,se,radius,nodeselect)
  function SetAAtype(set,aa)
  function setCyslist()
  function SetPuzzleProperties()
  function SetSelection(set)
  function Sort(tab,items) --BACWARD bubble sorting - lowest on top, only needed items
  function Wiggle(how, iters, minppi,onlyselected)


Local Variables:

  anychange=false
  ask = dialog.CreateDialog("Clash importance is not 1")
  b=range[1]
  ci1, ci2
  count = 0
  curscore=Score()
  Densitytot=GetSubscore("density")
  e=range[2]
  err
  Errfound=false
  f=0
  g=Score()-bestScore
  globshake
  how -- if how==nil then how="wa"
  i=1
  j=list[i]+1,list[i+1]-1
  iters -- if iters==nil then iters=3
  l=-1
  line = ""
  list1, list2 -- passed in to function SegmentJoinList(list1,list2)
  maxseg -- passed in to SegmentInvertSet(set,maxseg); if maxseg==nil then maxseg=structure.GetCount()
  minppi -- if minppi==nil then minppi=0.1
  mode -- if mode == nil then mode={}
  MutList=FindMutablesList()
  nodeselect
  onlyselected -- if onlyselected==nil then onlyselected=false
  pose -- if pose==nil then pose=current
  postfun
  prefun 
  radius
  range
  result={{1,structure.GetCount()}} -- All segments
  s=Score()
  saveselected=FindSelected()
  scr=Score()
  seg1, seg2
  segtot=GetSubscore(nil,1,segCnt)
  se
  set -- passed in to SegmentInvertSet(set,maxseg) and other segment functions
  show
  Showlist ="Computing Active Subscores"
  slot -- if slot == nil then slot=4
  sp=Score()
  ss
  Subs=puzzle.GetPuzzleSubscoreNames()
  title
  total=8000
  types
  wf=1
  x -- passed in to function round3(x); eg:round3(DENSITYWEIGHT),round3(Score())


Ask values:

  ask.AfterFuze = dialog.AddCheckbox("Mutate after Fuze",AfterFuze)
  ask.AfterQstab = dialog.AddCheckbox("Mutate after Qstab",AfterQstab)
  ask.AfterRB = dialog.AddCheckbox("Mutate after "..action,AfterRB)
  ask.bandflip=dialog.AddCheckbox("Disable bands during rebuild AND enable after",bandflip)
  ask.BeFuze = dialog.AddCheckbox("Mutate before Fuze",BeFuze)
  ask.bridge = dialog.AddCheckbox("Keep sulfide bridges intact",savebridges)
  ask.Cancel=dialog.AddButton("Cancel",0)
  ask.continue=dialog.AddButton("Continue",1)
  ask.disable=dialog.AddCheckbox("Run with disabled slow filters",Filteractive)
  ask.disjunct=dialog.AddCheckbox("Disjunct",disjunct)
  ask.donotrevisit = dialog.AddCheckbox("Do not things twice",donotrevisit)
  ask.doShake=dialog.AddCheckbox("Or Shake after "..action,doShake)
  ask.doSpecial=dialog.AddCheckbox("Local cleanup after "..action.." SLOW",doSpecial)
  ask.E1=dialog.AddLabel("Try again, ERRORS found, check output box")
  ask.fastQstab=dialog.AddCheckbox("Do a fast qStab",fastQstab)
  ask.helixes = dialog.AddCheckbox("Work on helixes",mode.defhelixes)
  ask.ignorefrozen = dialog.AddCheckbox("Dont work on frozen",true)
  ask.ignorelocks =dialog.AddCheckbox("Dont work on locked ones",true)
  ask.InQstab = dialog.AddCheckbox("Mutate during Qstab",InQstab)
  ask.l1=dialog.AddLabel("Last change to change it")
  ask.l1=dialog.AddLabel("Clear no revisit list if gain is more")
  ask.l1=dialog.AddLabel("-----What to rebuild, last one counts or all")
  ask.l1=dialog.AddLabel("Specify which slots based on scorepart to use")
  ask.l1=dialog.AddLabel("Specify which worst subscoretotal(s) to count")
  ask.l1=dialog.AddLabel("Length to rebuild, From can be bigger than To")
  ask.l2=dialog.AddLabel("If this is not the maximum bonus put in a number")
  ask.l2=dialog.AddLabel("Number of "..action.." each pass")
  ask.l2=dialog.AddLabel("Sphere size to use with surround")
  ask.l3=dialog.AddLabel("Scores will only be checked for real gains if")
  ask.l4=dialog.AddLabel("Score with filter off+maxbonus is a potential gain")
  ask.l6=dialog.AddLabel("Search only for disjunct from previous done")
  ask.ll3 = dialog.AddLabel("Force next round if gain is more")
  ask.ll3=dialog.AddLabel("Number of full cycles")
  ask.ll4 = dialog.AddLabel("Skip fuze if loss is more")
  ask.ll4=dialog.AddLabel("Skip first worst parts (crash resume)")
  ask.ll5 = dialog.AddLabel("Threshold used is RBlength*threshold/3")
  ask.lll=dialog.AddLabel("Wiggle more when CI is on its maximum")
  ask.ligands = dialog.AddCheckbox("Work on ligands",mode.defligands)
  ask.localshakes=dialog.AddCheckbox("Do shakes only local",localshakes)
  ask.loops = dialog.AddCheckbox("Work on loops",mode.defloops)
  ask.maxbonus=dialog.AddTextbox("Set maxbonus:",maxbonus)
  ask.maxLen = dialog.AddSlider("To length:",maxLen,1,10,0)
  ask.maxLoss = dialog.AddSlider("Skip fuze:",maxlossbeforefuze,-5,200,0)
  ask.minLen = dialog.AddSlider("From length:",minLen,1,10,0)
  ask.minGain = dialog.AddSlider("MinGain:",minGain,0,500,0)
  ask.MutateCI=dialog.AddSlider("MutateCI:",MutateCI,0.1,1,2)
  ask.mutateonly = dialog.AddCheckbox("Work only on mutateonly",mode.defmutateonly) end
  ask.MUTS = dialog.AddCheckbox("(Re)set Mutate Options",askmutable)
  ask.nofrozen=dialog.AddLabel("Frozen ones will be auto excluded")
  ask.nohelixes= dialog.AddLabel("Helixes will be auto excluded")
  ask.noligands= dialog.AddLabel("Ligands will be auto excluded")
  ask.nolocks=dialog.AddLabel("Locked ones will be auto excluded")
  ask.noloops= dialog.AddLabel("Loops will be auto excluded")
  ask.nonselected = dialog.AddCheckbox("Work only on nonselected",mode.defnonselected) end
  ask.nosheets= dialog.AddLabel("Sheets will be auto excluded")
  ask.nrcycles=dialog.AddSlider("Cycles:",maxnrofRuns,1,40,0)
  ask.nrrebuilds=dialog.AddSlider(action..":",rebuilds,1,100,0)
  ask.nrskip=dialog.AddSlider("Skip parts:",nrskip,0,segCnt2,0)
  ask.OK=dialog.AddButton("OK",1) 
  ask.OnlyRB=dialog.AddCheckbox("Mutate only "..action.." part",MUTRB)
  ask.OnlySur=dialog.AddCheckbox("Mutate "..action.." and surround",MUTSur)
  ask.Options = dialog.AddButton("More options",2)
  ask.R1=dialog.AddLabel("Or put in segmentranges. Above selections also count")
  ask.ranges=dialog.AddTextbox("Ranges","")
  ask.reBuild=dialog.AddSlider("#in first cycle:",reBuild,1,segCnt2,0)
  ask.reBuildm=dialog.AddSlider("#add each cycle:",reBuildmore,0,4,0)
  ask.revlist=dialog.AddSlider("Cleargain:",clrdonelistgain,0,500,0)
  ask.SEL= dialog.AddCheckbox("(Re)select where to work on ",false)
  ask.sel4=dialog.AddCheckbox("4 main slots, faster",Slot4)
  ask.selall=dialog.AddCheckbox("All slots",SlotAll)
  ask.selected = dialog.AddCheckbox("Work only on selected",mode.defselected) end
  ask.selSP= dialog.AddCheckbox("(Re)select slots",false)
  ask.shakeCI=dialog.AddSlider("Shake CI:",shakeCI,0,1,2)
  ask.sheets = dialog.AddCheckbox("Work on sheets",mode.defsheets)
  ask.skipfuze=dialog.AddCheckbox("Skip Fuze",skipfuze)
  ask.skipqstab=dialog.AddCheckbox("Local shake instead of Qstab",skipqstab)
  ask.slotl=dialog.AddLabel("Slot selection, last choice counts")
  ask.struct = dialog.AddCheckbox("Do not change all to loop",struct)
  ask.SurSize=dialog.AddSlider("Sphere:",MutSphere,3,15,0)
  ask.WF = dialog.AddSlider("WiggleFactor:",WF,1,5,0)
  ask.worst= dialog.AddCheckbox("(Re)set worst search params",false)

Mode values:

    if mode == nil then mode={} end
    if mode.askloops==nil then mode.askloops=true end
    if mode.asksheets==nil then mode.asksheets=true end
    if mode.askhelixes==nil then mode.askhelixes=true end
    if mode.askligands==nil then mode.askligands=false end
    if mode.askselected==nil then mode.askselected=true end
    if mode.asknonselected==nil then mode.asknonselected=true end
    if mode.askmutateonly==nil then mode.askmutateonly=true end
    if mode.askignorelocks==nil then mode.askignorelocks=true end
    if mode.askignorefrozen==nil then mode.askignorefrozen=true end
    if mode.askranges==nil then mode.askranges=true end
    if mode.defloops==nil then mode.defloops=true end
    if mode.defsheets==nil then mode.defsheets=true end
    if mode.defhelixes==nil then mode.defhelixes=true end
    if mode.defligands==nil then mode.defligands=false end
    if mode.defselected==nil then mode.defselected=false end
    if mode.defnonselected==nil then mode.defnonselected=false end
    if mode.defmutateonly==nil then mode.defmutateonly=false end
    if mode.defignorelocks==nil then mode.defignorelocks=false end
    if mode.defignorefrozen==nil then mode.defignorefrozen=false end


